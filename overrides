<?php

namespace Drupal\tna_legislation_publishing_user\Event;

use Drupal\tna_legislation_publishing_client\Exception\ClientException;
use Drupal\tna_legislation_publishing_user\Service\ForcedPasswordService;
use Drupal\tna_legislation_publishing_user\Service\ProfileUpdateDTO;
use symfony\component\DependencyInjection\ContainerInterface;

class ForcePasswordEvent {
  public function __construct(
    protected ForcedPasswordService $forcedPasswordService,
  ){}

  public static function createInstance(ContainerInterface $contaier){
    return new static(
        $contaier->get("tna_legislation_publishing_user.forced_password_service")
    );
  }
  public function checkResetRequired() {
    try{
        $resp = $this->forcedPasswordService->checkPasswordChangeRequired();
        $updateDTO = $this->parseXML($resp);
    }
    catch(ClientException $e){
        $e->getApiExceptionBody()->getMessage();
    }
    
  }
  protected function parseXML($resp) : ProfileUpdateDTO{
    $xml = simplexml_load_string($resp);
    $updatedto = new ProfileUpdateDTO();
    $updatedto->setOverall($xml["overall"]);
    $updatedto->setPasswordReset($xml->PasswordReset);
    $updatedto->setDepartamental($xml->Department);
    return $updatedto;
  }
}
this is the code which i have written 
Much of the code looks alright, but it would benefit from a restructure so it is actually called as you expect.
 
You have created an event. An event is to be broadcast so an event listener can add itself to the stack - whereas you want to listen for the login event. 
 
I'd suggest you duplicate the code of something like drupal/web/modules/custom/tna_legislation_publishing_roles/src/EventSubscriber/UserLoginSubscriber.php  to subscribe to the UserLoginEvent::NAME event and trigger your code in checkResetRequired
 
I'd move the parseXML into the forcedPasswordService rather than be a part of the event listener - so checkPasswordChangeRequired returns the Dto.
 
You would then need tor egister your event listener using the services.yml file, e.g.:
 
  tna_legislation_publishing_roles.user_login:
    class: Drupal\tna_legislation_publishing_roles\EventSubscriber\UserLoginSubscriber
    arguments: [
      '@entity_type.manager',
      '@tna_legislation_publishing_user.user_persistence',
      '@tna_legislation_publishing_roles.role_service'
    ]
    tags:
      - { name: 'event_subscriber' }
As it is a service you don't need the public static function createInstance(ContainerInterface $contaier){ style injection - you just add the services in the services.yml for inclusion in the constructor




this is the suggestion i got



<?php

namespace Drupal\tna_legislation_publishing_roles\EventSubscriber;

use Drupal\Core\Entity\EntityTypeManagerInterface;
use Drupal\tna_legislation_publishing_client\Exception\ClientException;
use Drupal\tna_legislation_publishing_roles\Service\RoleService;
use Drupal\tna_legislation_publishing_user\Event\UserLoginEvent;
use Drupal\tna_legislation_publishing_user\Service\UserPersistence;
use Drupal\user\Entity\Role;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpKernel\Exception\HttpException;

class UserLoginSubscriber implements EventSubscriberInterface {

  public function __construct(
    protected EntityTypeManagerInterface $entityTypeManager,
    protected UserPersistence $userPersistence,
    protected RoleService $roleService
  ) {}

  /**
   * @inheritDoc
   */
  public static function getSubscribedEvents(): array {
    return [
      UserLoginEvent::NAME => 'onUserLogin',
    ];
  }

  /**
   * Retrieve user roles from the API and apply to Drupal.
   *
   * @param \Drupal\tna_legislation_publishing_user\Event\UserLoginEvent $event
   *
   * @return void
   *
   * @throws \Drupal\Core\Entity\EntityStorageException
   */
  public function onUserLogin(UserLoginEvent $event): void {
    $account = $event->account;
    $uid = $event->account->id();

    // We provide a backdoor for pure Drupal admin, where the user admin user
    // does not login to the API, so they can access the site when the API is
    // down.
    if ($uid === '1') {
      return;
    }
    $email = $event->account->getEmail();

    try {
      $metadata = $this->userPersistence->getUserByEmail($email);

      $existingRoles = $account->getRoles();

      foreach ($existingRoles as $existingRole) {
        $account->removeRole($existingRole);
      }

      foreach ($metadata->getRoles() as $apiRole) {
        $drupalRole = Role::load(
          $this->roleService->formatApiNameToMachineName($apiRole->getName())
        );

        if ($drupalRole) {
          $account->addRole($drupalRole->id());
        }
      }

      $account->save();
    }
    catch (ClientException $exception) {
      throw new HttpException(
        'Unable to access role permissions system.',
        500
      );
    }
  }

}
this the code he mentioned now the objective is whenver user we need to send request to api but the problem is non of the above file got triiger when user login




function tna_legislation_publishing_user_user_login($account): void {
  // Instantiate our event.
  $event = new UserLoginEvent($account);

  /**
   * @var Drupal\Component\EventDispatcher\ContainerAwareEventDispatcher $event_dispatcher
   */
  $event_dispatcher = \Drupal::service('event_dispatcher');
  $event_dispatcher->dispatch($event, UserLoginEvent::NAME);
} this is the hook which we have defined
